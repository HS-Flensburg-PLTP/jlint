name: Haskell deployment

on:
  push:
    branches: [main]

jobs:
  stack-deploy:
    runs-on: self-hosted
    permissions:
      contents: write
    steps:
      - name: Checkout current repository
        uses: actions/checkout@v4

      - name: Setup Haskell with stack
        uses: haskell-actions/setup@v2
        with:
          enable-stack: true
          stack-no-global: true

      - name: Build dependencies only
        run: stack build --dependencies-only

      - name: Build
        run: stack build --force-dirty

      # the required secret SigningKey is an EC private key generated by
      #   openssl ecparam -genkey -name prime256v1 | openssl ec -aes256 -out priv.pem
      # to copy the key as a secret, output the passwordless private key
      #   openssl ec -in priv.pem
      # the corresponding public key can be generated using
      #   openssl ec -in priv.pem -pubout -out pub.pem
      # verification can then be performed with
      #   openssl dgst -verify pub.pem -keyform PEM -sha512 -signature signature -binary file
      # for dynamic changes in the used keypair it is recommended to set pubkey/VerificationKey
      # as an organization level "secret" for dependent workflows and use it like below
      - name: Copy build artifacts
        env:
          PRIVKEY: ${{ secrets.SigningKey }}
          FILENAME: "jlint"
        run: |
          DIST_FILE=$(stack exec which ${FILENAME})
          cp "${DIST_FILE}" .
          sha512sum --tag "${FILENAME}" > sha512sum
          echo "${PRIVKEY}" | openssl dgst -sign /dev/stdin -keyform PEM -sha512 -out signature "${FILENAME}"

      - name: Release artifacts
        uses: ncipollo/release-action@v1
        with:
          artifacts: |
            sha512sum
            signature
            jlint
          allowUpdates: true
          tag: latest
