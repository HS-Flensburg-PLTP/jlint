name: Haskell Deploy

on:
  push:
    branches: [ main, release ]
    tags: [ 'v*' ]
  release:
    types: [ created ]

jobs:
  stack-deploy:
    runs-on: self-hosted
    steps:
    - name: Checkout current repository
      uses: actions/checkout@v3

    - name: Setup Haskell with Stack
      uses: haskell/actions/setup@v2
      with:
        enable-stack: true
        stack-no-global: true

    - name: Stack Build Dependencies Only
      run: stack build --dependencies-only

    - name: Stack Build
      run: stack build --force-dirty

    # the required secret SigningKey is an EC private key generated by
    #   openssl ecparam -genkey -name prime256v1 | openssl ec -aes256 -out priv.pem
    # to copy the key as a secret, output the passwordless private key
    #   openssl ec -in priv.pem
    # the corresponding public key can be generated using
    #   openssl ec -in priv.pem -pubout -out pub.pem
    # verification can then be performed with
    #   openssl dgst -verify pub.pem -keyform PEM -sha512 -signature signature -binary file

    # for dynamic changes in the used keypair it is recommended to set pubkey/VerificationKey
    # as an organization level "secret" for dependent workflows and use it like below

    - name: Deploy from dist-dir
      env:
        PRIVKEY: ${{ secrets.SigningKey }}
        WEBROOT: "/srv/http/jlint"
        FILENAME: "jlint"
      run: |
        DIST_DIR=$(stack path --dist-dir)
        DIST_FILE="${DIST_DIR}/build/${FILENAME}/${FILENAME}"
        OUT_DIR="${WEBROOT}/${GITHUB_REF}"
        mkdir -p "${OUT_DIR}"
        cp -t "${OUT_DIR}" "${DIST_FILE}"
        cd "${OUT_DIR}"
        sha512sum --tag "${FILENAME}" > sha512sum
        echo "${PRIVKEY}" | openssl dgst -sign - -keyform PEM -sha512 -out signature "${FILENAME}"
